% This specification demonstrates the use of lpsconfcheck. It specifies
% a sender (S), two queues (Q1 and Q2) and a receiver (R). The sender sends elements
% of type Two through channel 1. The first queue receives elements from channel 1
% and eventually passes these on onto channel 2 in the same order. The second queue
% receives elements from channel 2 and eventually passes these on onto channel 3,
% again in the same order. The reader receives elements from channel 3 and
% immediately sends them onto channel 4. The communication on channels 1, 2 and 3 is
% hidden.
%
%
% Executing the following commands will yield LTS's of the system, produced with and
% without the use of tau priorisation.
%
% mcrl22lps -f -n queue.mcrl2 queue.lps
% lpsconfcheck queue.lps queue.marked.lps
% lps2lts queue.marked.lps queue.marked.svc -p ctau
% lps2lts queue.lps queue.svc
% ltsconvert queue.marked.svc queue.marked.fsm -l queue.lps
% ltsconvert queue.svc queue.fsm -l queue.lps
%
%
% Removing the equations "if(true, d1, d2) = d1)" and "if(false, d1, d2)" below
% makes it impossible for the prover to prove a number of the confluence conditions
% generated by lpsconfcheck. lpsconfcheck's verbose flag (-v) and counter-example flag
% (-c) facilitate finding such absent equations.
%
% The prover can apply induction on lists. Using induction, the prover can prove all
% the confluence conditions generated by lpsconfcheck for this specification, without
% needing the equations "rhead(d |> q) = if(q != [], rhead(q), d)" and
% "rtail(d |> q) = if(q != [], d |> rtail(q), [])".

sort
  Two;

cons
  t1, t2: Two;

var
  d: Two;

eqn
  t1 == t1 = true;
  t1 == t2 = false;
  t2 == t1 = false;
  t2 == t2 = true;
  d == d = true;

var
  d, d1, d2: Two;
  q: List(Two);
  a, b, c: Int;

eqn
%  rhead(d |> q) = if(q != [], rhead(q), d);
%  rtail(d |> q) = if(q != [], d |> rtail(q), []);
  if(true, d1, d2) = d1;
  if(false, d1, d2) = d2;

act
  r, s, r1, s1, r2, s2, r3, s3, s4, c1, c2, c3: Two;

proc
  Q(q: List(Two)) =
    sum d: Two. r(d) . Q(d |> q) +
    (q != []) -> s(rhead(q)) . Q(rtail(q));

  S = s1(t1) . s1(t2) . s1(t1) . s1(t2) . delta;

  R = sum d: Two. r3(d) . s4(d) . R;

  Q1 = rename({r -> r1, s -> s2}, Q([]));

  Q2 = rename({r -> r2, s -> s3}, Q([]));

init
  hide({c1, c2, c3}, allow({s4, c1, c2, c3}, comm({s1|r1 -> c1, s2|r2 -> c2, s3|r3 -> c3}, S || Q1 || Q2 || R)));
